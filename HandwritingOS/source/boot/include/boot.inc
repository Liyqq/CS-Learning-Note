;------------------- loader和kernel -------------------;
;内核加载器占用硬盘的扇区数
LOADER_CONSUMED_SECTOR_NUM equ 4

;内核加载器的扇区LBA地址：2扇区
LOADER_START_SECTOR_LBA_ADDR equ 0x02

;内核加载器被加载到内存后的开始内存地址
LOADER_BASE_MEM_ADDR equ 0x0900

;内核加载器栈顶地址
LOADER_STACK_TOP_MEM_ADDR equ LOADER_BASE_MEM_ADDR

;----------------------------------------;

;内核文件占用硬盘的扇区数
KERNEL_CONSUMED_SECTOR_NUM equ 200

;内核文件开始扇区
KERNEL_START_SECTOR_LAB_ADDR equ 0x09 

;内核镜像文件(可执行部分)的加载到内存中的内存基址
KERNEL_BIN_BASE_MEM_ADDR equ 0x7_0000

;内核的入口虚拟地址
KERNEL_ENTRY_POINT equ 0xc000_1500

;内核栈顶地址
;为对齐PCB(4KB)，在0x9fbff为最大可选地址时，选用最佳的0x9f000
KERNEL_STACK_TOP_MEM_ADDR equ 0xc009_f000


;------------------- ELF文件属性 -------------------;
;预先定义的数据类型
;------------+---------+-----+-------------------
; 数据类型名称 | 字节大小 | 对齐 |        意义
;------------+---------+-----+-------------------
;Elf32_Half  |    2    |  2  | 无符号中等大小的整数  
;------------+---------+-----+-------------------
;Elf32_Word  |    4    |  4  | 无符号大整数
;------------+---------+-----+-------------------
;Elf32_Addr  |    4    |  4  | 无符号程序运行地址
;------------+---------+-----+-------------------
;Elf32_Off   |    4    |  4  | 无符号的文件偏移量
;------------+---------+-----+-------------------
;
;---------- 程序段属性 ----------
;typedef struct
;{
;    Elf32_Word    p_type;         /* Segment type              */
;    Elf32_Off     p_offset;       /* Segment file offset       */
;    Elf32_Addr    p_vaddr;        /* Segment virtual address   */
;    Elf32_Addr    p_paddr;        /* Segment physical address  */
;    Elf32_Word    p_filesz;       /* Segment size in file      */
;    Elf32_Word    p_memsz;        /* Segment size in memory    */
;    Elf32_Word    p_flags;        /* Segment flags             */
;    Elf32_Word    p_align;        /* Segment alignment         */
;} Elf32_Phdr;
;p_type：占用4字节，用来指明程序中该段的类型。
;        类型    |    取值    |     说明
;    -----------+------------+--------------------
;    PT_NULL    |     0      |   忽略
;    -----------+------------+--------------------
;    PT_LOAD    |     1      |   可加载程序段
;    -----------+------------+--------------------
;    PT_DYNAMIC |     2      |   动态链接信息
;    -----------+------------+--------------------
;    PT_INTERP  |     3      |   动态加载器名称
;    -----------+------------+--------------------
;    PT_NOTE    |     4      |   一些辅助的附加信息
;    -----------+------------+--------------------
;    PT_SHLIB   |     5      |   保留
;    -----------+------------+--------------------
;    PT_PHDR    |     6      |   程序头表
;    -----------+------------+--------------------
;    PT_LOPROC  | 0x70000000 |  此范围内的类型
;    -----------+------------+
;    PT_HIPROC  | 0x7fffffff |  预留给处理器专用
;    -----------+------------+--------------------
PT_NULL     equ     0





;------------------- GDT段描述符格式 -------------------;
;该结构专门用来描述一个内存段，8字节大小(64位)
;高32位
; 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
;+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;| mem segment base addr |  |D |  |A |mem segment|  |     |  |           | mem segment base addr |
;|                       |G |/ |L |V |   limit   |P | DPL |S |    TYPE   |                       |
;|      31 ~ 24 bits     |  |B |  |L | 19~16 bits|  |     |  |           |      23 ~ 16 bits     |
;+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;G：Granularity粒度，用来指定段界限的单位大小。0表示1字节，1表示4KB。
;D/B：指示有效地址（段内偏移地址）及操作数的大小，这是为了兼容80286的保护模式设定的，
;    80286的保护模式下的操作数是16位。
;    D位：0表示指令中的有效地址和操作数是16位，指令有效地址用IP寄存器。
;        1表示指令中的有效地址及操作数是32位，指令有效地址用EIP寄存器。
;    B位：用来指定操作数大小，此操作数涉及到栈指针寄存器的选择及栈的地址上限。
;        0表示使用的是SP寄存器，栈的起始地址是16位寄存器的最大寻址范围0xFFFF。 
;        1表示使用的是ESP寄存器，栈的起始地址是32位寄存器的最大寻址范围0xFFFFFFFF。
;L：用于设置是否是64位代码段。1表示64位代码段，0表示32位代码段。
;AVL：AVaiLable，表示该内存段对用户是否可用。
;P：Present，即段是否存在。1表示段存在于内存中，否则P为0。常用于内存交换中。
;DPL：Descriptor Privilege Level，即描述符特权级，这是保护模式提供的安全解决方案，
;    分别是0、1、2、3级特权，数字越小，特权级越大。
;    操作系统应该处于最高的0特权级。用户程序通常处于权限最小的3特权级。
;S：指定内存段为系统段还是数据段，0表示系统段，1表示数据段。
;TYPE：和S字段配合在一起确定段描述符的确切类型，只有S字段的值确定后，TYPE字段的值才有具体意义。
;
;;低32位
; 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8  7  6  5  4  3  2  1  0
;+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;|             mem segment base addr             |               mem segment limit               |
;|                                               |                                               |
;|                  15 ~ 0 bits                  |                   15 ~ 0 bits                 |
;+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+
;------------------- GDT段描述符属性 -------------------;
DESC_G_4K   equ    1__000_0000_0000_0000_0000_0000b
DESC_D_32   equ     1__00_0000_0000_0000_0000_0000b
DESC_L      equ      0__0_0000_0000_0000_0000_0000b     ;64位代码标记，此处标记为0即可。
DESC_AVL    equ        0__0000_0000_0000_0000_0000b     ;CPU不使用此位，置0即可。

DESC_LIMIT_CODE_H32  equ 1111__0000_0000_0000_0000b     ;段界限在高32位的部分，
                                                        ;与低32位中部分共同组成20位1
                                                        ;一起表示界限0xFFFFF
DESC_LIMIT_DATA_H32  equ DESC_LIMIT_CODE_H32            ;同上
DESC_LIMIT_VIDEO_H32 equ 0000__0000_0000_0000_0000b

DESC_P      equ              1__000_0000_0000_0000b     

DESC_DPL_0  equ               00__0_0000_0000_0000b
DESC_DPL_1  equ               01__0_0000_0000_0000b
DESC_DPL_2  equ               10__0_0000_0000_0000b
DESC_DPL_3  equ               11__0_0000_0000_0000b

DESC_S_SYS  equ                  0__0000_0000_0000b     ;系统段
DESC_S_CODE equ                  1__0000_0000_0000b     ;非系统段且指代码段
DESC_S_DATA equ  DESC_S_CODE                            ;非系统段且指数据段

DESC_TYPE_CODE  equ                1000__0000_0000b     ;x=1,c=,r=0,a=0
                                                        ;代码段是可执行的，非依从的，
                                                        ;不可读的，已访问位a清0。
DESC_TYPE_DATA  equ                0010__0000_0000b     ;x=0,c=,r=1,a=0
                                                        ;代码段是不可执行的，向上扩展的，
                                                        ;可写的，已访问位a清0。

;代码段描述符的高32位表示，其中(0x00 << 24表示最高8位的段基址值，
;由于我们采用的是平坦模型，故基址为0)，后面唯一可变的就是段界限值。
;定义代码段的高32位
DESC_CODE_HIGH32  equ   (0x00 << 24) + DESC_G_4K + DESC_D_32 + \
                        DESC_L + DESC_AVL + DESC_LIMIT_CODE_H32 + \
                        DESC_P + DESC_DPL_0 + DESC_S_CODE + \
                        DESC_TYPE_CODE + 0x00
;定义数据段的高32位
DESC_DATA_HIGH32  equ   (0x00 << 24) + DESC_G_4K + DESC_D_32 + \
                        DESC_L + DESC_AVL + DESC_LIMIT_DATA_H32 + \
                        DESC_P + DESC_DPL_0 + DESC_S_DATA + \
                        DESC_TYPE_DATA + 0x00

DESC_VIDEO_HIGH32 equ   (0x00 << 24) + DESC_G_4K + DESC_D_32 + \
                        DESC_L + DESC_AVL + DESC_LIMIT_VIDEO_H32 + \
                        DESC_P + DESC_DPL_0 + DESC_S_DATA + \
                        DESC_TYPE_DATA + 0x0b


;------------------- 段选择子属性 -------------------;
;选择子表示所需要的段的描述符在描述符表的位置，由这个位置再根据在GDTR中存储的描述符表基址
;就可以找到相应的描述符。
;用给出的选择子索引到描述符后，CPU自动从段描述符中取出段基址，再加上段内偏移地址，便凑成
;了“段基址：段内偏移地址”的形式的线性地址。
; 
;由于段寄存器是16位，所以选择子也是16位，其结构如下
; 15  14  13  12  11  10   9   8   7   6   5   4   3   2   1   0
;+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
;|                  Descriptor Index                 |TI |  RPL  |
;+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+
;RPL：表示请求特权级，有0、1、2、3四种特权级
;TI：即Table Indicator，用来指定选择子是在GDT中，还是LDT中。
;   0表示在GDT中索引描述符；
;   1表示在LDT中索引描述符。
;选择子的高13位，即第3~15位是描述符的索引值，相当于GDT的下标，最多可索引2^13=8192个段描述符。
SELECTOR_RPL_0   equ  00b
SELECTOR_RPL_1   equ  01b
SELECTOR_RPL_2   equ  10b
SELECTOR_RPL_3   equ  11b

SELECTOR_TI_GDT  equ  0_00b
SELECTOR_TI_LDT  equ  1_00b


;------------------- 页表相关属性 -------------------;
;
;页是地址空间的计量单位，并不是专属物理地址或线性地址，只要是4KB的地址空间都可以称为一
;页，所以线性地址的一页也要对应物理地址的一页。一页大小为4KB
;
;
;页表就是个N行1列的表格，页表中的每一行称为页表项(Page Table Entry, PTE)，其大小
;是4字节，页表项的作用是存储内存物理地址。当访问一个线性地址时，实际上就是在访问页表项
;中所记录的物理内存地址。
;页表项结构如下
; 31                12 11 10 9  8  7  6  5  4  3  2  1  0
;+--------------------+--+--+--+--+--+--+--+--+--+--+--+--+
;|   physical page    |        |  |P |  |  |P |P |U |R |  |
;|        addr        |  A V L |G |A |D |A |C |W |/ |/ |P |
;|      20 bits       |        |  |T |  |  |D |T |S |W |  |
;+--------------------+--+--+--+--+--+--+--+--+--+--+--+--+
;
;
;每个页表的物理地址在页目录表中都以页目录项(Page Directory Entry, PDE)的形式存储，
;页目录项大小同页表项一样，都用来描述一个物理页的物理地址，其大小都是4字节，而且最多有
;1024个页表，所以页目录表也是4KB大小，同样也是标准页的大小。
;页目录项结构如下
; 31                12 11 10 9  8  7  6  5  4  3  2  1  0
;+--------------------+--+--+--+--+--+--+--+--+--+--+--+--+
;|     page table     |        |  |P |  |  |P |P |U |R |  |
;| physical page addr |  A V L |G |A |D |A |C |W |/ |/ |P |
;|    addr 20 bits    |        |  |T |  |  |D |T |S |W |  |
;+--------------------+--+--+--+--+--+--+--+--+--+--+--+--+
;P：Present，意为存在位。
;    为1表示该页存在于物理内存中，
;    为0表示该表不在物理内存中。
;    操作系统的页式虚拟内存管理便是通过P位和相应的pagefault异常来实现的。
;R/W：Read/Write，意为读写位。
;    为1表示可读可写，
;    为0表示可读不可写。
;U/S：User/Supervisor，意为普通用户/超级用户位。
;    为1表示处于User级，任意级别(0、1、2、3)特权的程序都可以访问该页。
;    为0表示处于Supervisor级，该页只允许特权级别为(0、1、2)的程序访问。
;PWT：Page-level Write-Through，意为页级通写位，也称页级写透位。
;    为1表示此项采用通写方式，表示该页不仅是普通内存，还是高速缓存。此项和高速缓存有关，
;    “通写”是高速缓存的一种工作方式，本位用来间接决定是否用此方式改善该页的访问效率。
;    这里直接置为0即可。
;PCD：Page-level Cache Disable，意为页级高速缓存禁止位。
;    为1表示该页启用高速缓存，
;    为0表示禁止将该页缓存。这里将其置0。
;A：Accessed，意为访问位。
;    为1表示该页被CPU访问过，由CPU设置的。
;    为0表示该页未被CPU访问过，由操作系统设置。
;    这里页目录项和页表项中的A位也可以用来记录某一内存页的使用频率（操作系统定期将该位清0，
;    统计一段时间内变成1的次数），从而当内存不足时，可以将使用频率较低的页面换出到外存，同
;    时将页目录项或页表项的P位置0，下次访问该页引起pagefault异常时，中断处理程序将硬盘上
;    的页再次换入，同时将P位置 1。
;D：Dirty，意为脏页位。当CPU 对一个页面执行写操作时，就会设置对应页表项的D位为1。此项仅针
;    对页表项有效，并不会修改页目录项中的D位。
;PAT：Page Attribute Table，意为页属性表位，能够在页面一级的粒度上设置内存属性。比较复杂，
;    将此位置0即可。
;G：Global，意为全局位。由于内存地址转换也是颇费周折，为了提高获取物理地址的速度，将虚拟地址
;    与物理地址转换结果存储在TLB(Translation Lookaside Buffer)中，
;    为1表示是全局页，该页将在高速缓存TLB中一直保存，给出虚拟地址直接获取物理地址。
;    为0表示不是全局页。
;    清空TLB有两种方式，一是用invlpg指令针对单独虚拟地址条目清理，
;    或者是重新加载CR3寄存器，这将直接清空TLB。
;AVL，意为Available位，表示可用。软件（操作系统）可用该位，CPU不理会该位的值。
;
;二级页目录表，页表放在内存中1M起始位置连续存放，尽可能简单
PAGE_DIR_TABLE_BASE_ADDR equ 0x100000
;页表项属性
PAGE_P    equ 1b
PAGE_RW_R equ 00b
PAGE_RW_W equ 10b
PAGE_US_U equ 000b
PAGE_US_S equ 100b
